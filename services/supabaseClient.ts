

import { createClient } from '@supabase/supabase-js';
import { SUPABASE_CONFIG } from '../config';

// Note: The Supabase client is initialized with placeholder credentials.
// You must replace them in `config.ts` with your actual Supabase project details.
export const supabase = createClient(SUPABASE_CONFIG.URL, SUPABASE_CONFIG.ANON_KEY, {
  global: {
    // By default, the Supabase client might cache API responses. This can lead to issues
    // on page reload where stale data causes the app to hang.
    // By setting 'Cache-Control' to 'no-cache', we ensure the app always fetches
    // fresh data, definitively resolving the stuck loading screen issue.
    headers: { 'Cache-Control': 'no-cache' },
  },
});


/*
-- This script fixes the database security configuration.
-- Run this ENTIRE script in your Supabase SQL Editor. It is safe to run multiple times.

-- Drop existing objects to ensure a clean slate.
DROP FUNCTION IF EXISTS public.handle_new_user() CASCADE;
DROP FUNCTION IF EXISTS public.sync_user_role_to_auth() CASCADE;
DROP FUNCTION IF EXISTS public.get_current_user_role() CASCADE;
DROP FUNCTION IF EXISTS public.convert_quotation_to_invoice(BIGINT) CASCADE;
DROP FUNCTION IF EXISTS public.create_quotation_with_items(JSONB, JSONB) CASCADE;
DROP FUNCTION IF EXISTS public.update_quotation_with_items(BIGINT, JSONB, JSONB) CASCADE;
DROP FUNCTION IF EXISTS public.create_invoice_with_items(JSONB, JSONB) CASCADE;
DROP FUNCTION IF EXISTS public.update_invoice_with_items(BIGINT, JSONB, JSONB) CASCADE;
DROP FUNCTION IF EXISTS public.create_supplier_invoice_with_items(JSONB, JSONB) CASCADE;
DROP FUNCTION IF EXISTS public.update_supplier_invoice_with_items(BIGINT, JSONB, JSONB) CASCADE;
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
DROP TRIGGER IF EXISTS on_user_profile_change ON public.users;
DROP TABLE IF EXISTS public.quotation_items CASCADE;
DROP TABLE IF EXISTS public.invoice_items CASCADE;
DROP TABLE IF EXISTS public.supplier_invoice_items CASCADE;
DROP TABLE IF EXISTS public.receipt_vouchers CASCADE;
DROP TABLE IF EXISTS public.payment_vouchers CASCADE;
DROP TABLE IF EXISTS public.quotations CASCADE;
DROP TABLE IF EXISTS public.invoices CASCADE;
DROP TABLE IF EXISTS public.supplier_invoices CASCADE;
DROP TABLE IF EXISTS public.products CASCADE;
DROP TABLE IF EXISTS public.customers CASCADE;
DROP TABLE IF EXISTS public.suppliers CASCADE;
DROP TABLE IF EXISTS public.users CASCADE;
DROP TABLE IF EXISTS public.roles CASCADE;
DROP TYPE IF EXISTS public.product_type CASCADE;
DROP TYPE IF EXISTS public.document_status CASCADE;
DROP TYPE IF EXISTS public.payment_method CASCADE;


-- 1. ROLES TABLE
CREATE TABLE public.roles (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL
);
ALTER TABLE public.roles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public can view roles" ON public.roles FOR SELECT USING (true);
INSERT INTO public.roles (id, name) VALUES ('admin', 'Admin'), ('accountant', 'Accountant'), ('sales_manager', 'Sales Manager'), ('sales_person', 'Sales Person');

-- 2. USERS TABLE
CREATE TABLE public.users (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name TEXT,
  role TEXT REFERENCES public.roles(id) DEFAULT 'sales_person',
  manager_id UUID REFERENCES public.users(id) ON DELETE SET NULL
);
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

-- 3. NEW USER TRIGGER
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.users (id, full_name)
  VALUES (new.id, new.raw_user_meta_data->>'full_name');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- 4. ROLE SYNC TRIGGER (The key fix for recursion)
CREATE OR REPLACE FUNCTION public.sync_user_role_to_auth()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE auth.users
  SET raw_user_meta_data = raw_user_meta_data || jsonb_build_object('role', NEW.role)
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
CREATE TRIGGER on_user_profile_change
  AFTER INSERT OR UPDATE OF role ON public.users
  FOR EACH ROW EXECUTE FUNCTION public.sync_user_role_to_auth();

-- 5. NON-RECURSIVE RLS POLICIES
-- Users
CREATE POLICY "Users can view and update their own profile" ON public.users
  FOR ALL USING (auth.uid() = id)
  WITH CHECK (auth.uid() = id);
CREATE POLICY "Admins can manage all user profiles" ON public.users
  FOR ALL USING (((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) = 'admin');

-- Customers
CREATE TABLE public.customers (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name TEXT NOT NULL, email TEXT, phone TEXT, address TEXT, created_at TIMESTAMPTZ DEFAULT NOW(), created_by UUID REFERENCES public.users(id) ON DELETE SET NULL DEFAULT auth.uid());
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage customers based on ownership and role" ON public.customers FOR ALL
USING (created_by = auth.uid() OR ((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) IN ('admin', 'accountant') OR (((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) = 'sales_manager' AND created_by IN (SELECT id FROM public.users WHERE manager_id = auth.uid())));

-- Suppliers
CREATE TABLE public.suppliers (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name TEXT NOT NULL, email TEXT, phone TEXT, address TEXT, created_at TIMESTAMPTZ DEFAULT NOW(), created_by UUID REFERENCES public.users(id) ON DELETE SET NULL DEFAULT auth.uid());
ALTER TABLE public.suppliers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage suppliers based on ownership and role" ON public.suppliers FOR ALL
USING (created_by = auth.uid() OR ((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) IN ('admin', 'accountant') OR (((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) = 'sales_manager' AND created_by IN (SELECT id FROM public.users WHERE manager_id = auth.uid())));

-- Products
CREATE TYPE public.product_type AS ENUM ('product', 'service');
CREATE TABLE public.products (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    price NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
    type public.product_type NOT NULL DEFAULT 'product',
    category TEXT,
    unit TEXT,
    avg_purchase_price NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
    avg_selling_price NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Authenticated users can manage products" ON public.products FOR ALL USING (auth.role() = 'authenticated');

-- Quotations
CREATE TYPE public.document_status AS ENUM ('draft', 'sent', 'accepted', 'rejected', 'paid', 'overdue', 'unpaid', 'partially_paid');
CREATE TABLE public.quotations (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, customer_id BIGINT REFERENCES public.customers(id) ON DELETE SET NULL, issue_date DATE NOT NULL DEFAULT CURRENT_DATE, status public.document_status NOT NULL DEFAULT 'draft', subtotal NUMERIC(10, 2) NOT NULL DEFAULT 0.00, tax_rate NUMERIC(5, 2) NOT NULL DEFAULT 0.00, tax_amount NUMERIC(10, 2) NOT NULL DEFAULT 0.00, total NUMERIC(10, 2) NOT NULL DEFAULT 0.00, created_at TIMESTAMPTZ DEFAULT NOW(), created_time TIME DEFAULT CURRENT_TIME, created_by UUID REFERENCES public.users(id) ON DELETE SET NULL DEFAULT auth.uid(), is_taxable BOOLEAN DEFAULT true, discount_amount NUMERIC(10, 2) DEFAULT 0, discount_type TEXT DEFAULT 'amount', contact_person TEXT, project_name TEXT, quotation_type TEXT);
ALTER TABLE public.quotations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage quotations based on ownership and role" ON public.quotations FOR ALL
USING (created_by = auth.uid() OR ((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) IN ('admin', 'accountant') OR (((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) = 'sales_manager' AND created_by IN (SELECT id FROM public.users WHERE manager_id = auth.uid())));

-- Quotation Items
CREATE TABLE public.quotation_items (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, quotation_id BIGINT NOT NULL REFERENCES public.quotations(id) ON DELETE CASCADE, product_id BIGINT REFERENCES public.products(id) ON DELETE SET NULL, description TEXT, unit TEXT, quantity INT NOT NULL DEFAULT 1, price NUMERIC(10, 2) NOT NULL, total NUMERIC(10, 2) GENERATED ALWAYS AS (quantity * price) STORED);
ALTER TABLE public.quotation_items ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage items based on parent document" ON public.quotation_items FOR ALL USING ((SELECT q.created_by FROM public.quotations q WHERE q.id = quotation_id) = auth.uid() OR ((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) IN ('admin', 'accountant') OR (((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) = 'sales_manager' AND (SELECT q.created_by FROM public.quotations q WHERE q.id = quotation_id) IN (SELECT u.id FROM public.users u WHERE u.manager_id = auth.uid())));

-- Invoices
CREATE TABLE public.invoices (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, customer_id BIGINT REFERENCES public.customers(id) ON DELETE SET NULL, quotation_id BIGINT REFERENCES public.quotations(id) ON DELETE SET NULL, issue_date DATE NOT NULL DEFAULT CURRENT_DATE, due_date DATE NOT NULL, status public.document_status NOT NULL DEFAULT 'draft', subtotal NUMERIC(10, 2) NOT NULL DEFAULT 0.00, tax_rate NUMERIC(5, 2) NOT NULL DEFAULT 0.00, tax_amount NUMERIC(10, 2) NOT NULL DEFAULT 0.00, total NUMERIC(10, 2) NOT NULL DEFAULT 0.00, paid_amount NUMERIC(10, 2) NOT NULL DEFAULT 0.00, created_at TIMESTAMPTZ DEFAULT NOW(), created_time TIME DEFAULT CURRENT_TIME, created_by UUID REFERENCES public.users(id) ON DELETE SET NULL DEFAULT auth.uid(), is_taxable BOOLEAN DEFAULT true, discount_amount NUMERIC(10, 2) DEFAULT 0, discount_type TEXT DEFAULT 'amount', contact_person TEXT, project_name TEXT, invoice_type TEXT);
ALTER TABLE public.invoices ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage invoices based on ownership and role" ON public.invoices FOR ALL
USING (created_by = auth.uid() OR ((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) IN ('admin', 'accountant') OR (((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) = 'sales_manager' AND created_by IN (SELECT id FROM public.users WHERE manager_id = auth.uid())));

-- Invoice Items
CREATE TABLE public.invoice_items (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, invoice_id BIGINT NOT NULL REFERENCES public.invoices(id) ON DELETE CASCADE, product_id BIGINT REFERENCES public.products(id) ON DELETE SET NULL, description TEXT, unit TEXT, quantity INT NOT NULL DEFAULT 1, price NUMERIC(10, 2) NOT NULL, total NUMERIC(10, 2) GENERATED ALWAYS AS (quantity * price) STORED);
ALTER TABLE public.invoice_items ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage items based on parent document" ON public.invoice_items FOR ALL USING ((SELECT i.created_by FROM public.invoices i WHERE i.id = invoice_id) = auth.uid() OR ((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) IN ('admin', 'accountant') OR (((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) = 'sales_manager' AND (SELECT i.created_by FROM public.invoices i WHERE i.id = invoice_id) IN (SELECT u.id FROM public.users u WHERE u.manager_id = auth.uid())));

-- Supplier Invoices
CREATE TABLE public.supplier_invoices (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, supplier_id BIGINT REFERENCES public.suppliers(id) ON DELETE SET NULL, issue_date DATE NOT NULL DEFAULT CURRENT_DATE, due_date DATE NOT NULL, status public.document_status NOT NULL DEFAULT 'unpaid', subtotal NUMERIC(10, 2) NOT NULL DEFAULT 0.00, tax_rate NUMERIC(5, 2) NOT NULL DEFAULT 0.00, tax_amount NUMERIC(10, 2) NOT NULL DEFAULT 0.00, total NUMERIC(10, 2) NOT NULL DEFAULT 0.00, paid_amount NUMERIC(10, 2) NOT NULL DEFAULT 0.00, created_at TIMESTAMPTZ DEFAULT NOW(), created_time TIME DEFAULT CURRENT_TIME, created_by UUID REFERENCES public.users(id) ON DELETE SET NULL DEFAULT auth.uid(), is_taxable BOOLEAN DEFAULT true, discount_amount NUMERIC(10, 2) DEFAULT 0, discount_type TEXT DEFAULT 'amount', contact_person TEXT, project_name TEXT, supplier_invoice_type TEXT);
ALTER TABLE public.supplier_invoices ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage supplier invoices based on role" ON public.supplier_invoices FOR ALL USING (((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) IN ('admin', 'accountant'));

-- Supplier Invoice Items
CREATE TABLE public.supplier_invoice_items (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, supplier_invoice_id BIGINT NOT NULL REFERENCES public.supplier_invoices(id) ON DELETE CASCADE, product_id BIGINT REFERENCES public.products(id) ON DELETE SET NULL, product_name TEXT NOT NULL, description TEXT, unit TEXT, quantity INT NOT NULL DEFAULT 1, price NUMERIC(10, 2) NOT NULL, total NUMERIC(10, 2) GENERATED ALWAYS AS (quantity * price) STORED);
ALTER TABLE public.supplier_invoice_items ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage items based on parent document" ON public.supplier_invoice_items FOR ALL USING (((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) IN ('admin', 'accountant'));

-- Vouchers
CREATE TYPE public.payment_method AS ENUM ('cash', 'bank_transfer', 'cheque');
CREATE TABLE public.receipt_vouchers (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, customer_id BIGINT REFERENCES public.customers(id) ON DELETE SET NULL, date DATE NOT NULL DEFAULT CURRENT_DATE, amount NUMERIC(10, 2) NOT NULL, payment_method public.payment_method NOT NULL DEFAULT 'cash', description TEXT, created_at TIMESTAMPTZ DEFAULT NOW(), created_time TIME DEFAULT CURRENT_TIME, created_by UUID REFERENCES public.users(id) ON DELETE SET NULL DEFAULT auth.uid());
ALTER TABLE public.receipt_vouchers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Accountants and admins can manage receipts" ON public.receipt_vouchers FOR ALL USING ( ((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) IN ('admin', 'accountant') );
CREATE TABLE public.payment_vouchers (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, supplier_id BIGINT REFERENCES public.suppliers(id) ON DELETE SET NULL, date DATE NOT NULL DEFAULT CURRENT_DATE, amount NUMERIC(10, 2) NOT NULL, payment_method public.payment_method NOT NULL DEFAULT 'cash', description TEXT, created_at TIMESTAMPTZ DEFAULT NOW(), created_time TIME DEFAULT CURRENT_TIME, created_by UUID REFERENCES public.users(id) ON DELETE SET NULL DEFAULT auth.uid());
ALTER TABLE public.payment_vouchers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Accountants and admins can manage payments" ON public.payment_vouchers FOR ALL USING ( ((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) IN ('admin', 'accountant') );

-- ================== RPC FUNCTIONS ==================

-- QUOTATIONS --
CREATE OR REPLACE FUNCTION public.create_quotation_with_items(quotation_data JSONB, items_data JSONB)
RETURNS BIGINT AS $$
DECLARE
    new_quotation_id BIGINT;
    item JSONB;
BEGIN
    INSERT INTO public.quotations (customer_id, issue_date, status, subtotal, tax_rate, tax_amount, total, created_by, is_taxable, discount_amount, discount_type, contact_person, project_name, quotation_type)
    VALUES (
        (quotation_data->>'customer_id')::BIGINT, (quotation_data->>'issue_date')::DATE, (quotation_data->>'status')::public.document_status,
        (quotation_data->>'subtotal')::NUMERIC, (quotation_data->>'tax_rate')::NUMERIC, (quotation_data->>'tax_amount')::NUMERIC, (quotation_data->>'total')::NUMERIC,
        auth.uid(), (quotation_data->>'is_taxable')::BOOLEAN, (quotation_data->>'discount_amount')::NUMERIC, (quotation_data->>'discount_type')::TEXT,
        quotation_data->>'contact_person', quotation_data->>'project_name', quotation_data->>'quotation_type'
    ) RETURNING id INTO new_quotation_id;

    IF items_data IS NOT NULL THEN
        FOR item IN SELECT * FROM jsonb_array_elements(items_data) LOOP
            INSERT INTO public.quotation_items (quotation_id, product_id, description, unit, quantity, price)
            VALUES (new_quotation_id, (item->>'product_id')::BIGINT, item->>'description', item->>'unit', (item->>'quantity')::INT, (item->>'price')::NUMERIC);
        END LOOP;
    END IF;
    RETURN new_quotation_id;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.update_quotation_with_items(p_quotation_id BIGINT, quotation_data JSONB, items_data JSONB)
RETURNS VOID AS $$
DECLARE
    item JSONB;
BEGIN
    UPDATE public.quotations SET
        customer_id = (quotation_data->>'customer_id')::BIGINT, issue_date = (quotation_data->>'issue_date')::DATE, status = (quotation_data->>'status')::public.document_status,
        subtotal = (quotation_data->>'subtotal')::NUMERIC, tax_rate = (quotation_data->>'tax_rate')::NUMERIC, tax_amount = (quotation_data->>'tax_amount')::NUMERIC, total = (quotation_data->>'total')::NUMERIC,
        is_taxable = (quotation_data->>'is_taxable')::BOOLEAN, discount_amount = (quotation_data->>'discount_amount')::NUMERIC, discount_type = (quotation_data->>'discount_type')::TEXT,
        contact_person = quotation_data->>'contact_person', project_name = quotation_data->>'project_name', quotation_type = quotation_data->>'quotation_type'
    WHERE id = p_quotation_id;
    DELETE FROM public.quotation_items WHERE quotation_id = p_quotation_id;
    IF items_data IS NOT NULL THEN
        FOR item IN SELECT * FROM jsonb_array_elements(items_data) LOOP
            INSERT INTO public.quotation_items (quotation_id, product_id, description, unit, quantity, price)
            VALUES (p_quotation_id, (item->>'product_id')::BIGINT, item->>'description', item->>'unit', (item->>'quantity')::INT, (item->>'price')::NUMERIC);
        END LOOP;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- INVOICES --
CREATE OR REPLACE FUNCTION public.create_invoice_with_items(invoice_data JSONB, items_data JSONB)
RETURNS BIGINT AS $$
DECLARE
    new_invoice_id BIGINT;
    item JSONB;
BEGIN
    INSERT INTO public.invoices (customer_id, issue_date, due_date, status, subtotal, tax_rate, tax_amount, total, paid_amount, created_by, is_taxable, discount_amount, discount_type, contact_person, project_name, invoice_type)
    VALUES (
        (invoice_data->>'customer_id')::BIGINT, (invoice_data->>'issue_date')::DATE, (invoice_data->>'due_date')::DATE, (invoice_data->>'status')::public.document_status,
        (invoice_data->>'subtotal')::NUMERIC, (invoice_data->>'tax_rate')::NUMERIC, (invoice_data->>'tax_amount')::NUMERIC, (invoice_data->>'total')::NUMERIC, (invoice_data->>'paid_amount')::NUMERIC,
        auth.uid(), (invoice_data->>'is_taxable')::BOOLEAN, (invoice_data->>'discount_amount')::NUMERIC, (invoice_data->>'discount_type')::TEXT,
        invoice_data->>'contact_person', invoice_data->>'project_name', invoice_data->>'invoice_type'
    ) RETURNING id INTO new_invoice_id;
    IF items_data IS NOT NULL THEN
        FOR item IN SELECT * FROM jsonb_array_elements(items_data) LOOP
            INSERT INTO public.invoice_items (invoice_id, product_id, description, unit, quantity, price)
            VALUES (new_invoice_id, (item->>'product_id')::BIGINT, item->>'description', item->>'unit', (item->>'quantity')::INT, (item->>'price')::NUMERIC);
        END LOOP;
    END IF;
    RETURN new_invoice_id;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.update_invoice_with_items(p_invoice_id BIGINT, invoice_data JSONB, items_data JSONB)
RETURNS VOID AS $$
DECLARE
    item JSONB;
BEGIN
    UPDATE public.invoices SET
        customer_id = (invoice_data->>'customer_id')::BIGINT, issue_date = (invoice_data->>'issue_date')::DATE, due_date = (invoice_data->>'due_date')::DATE, status = (invoice_data->>'status')::public.document_status,
        subtotal = (invoice_data->>'subtotal')::NUMERIC, tax_rate = (invoice_data->>'tax_rate')::NUMERIC, tax_amount = (invoice_data->>'tax_amount')::NUMERIC, total = (invoice_data->>'total')::NUMERIC,
        is_taxable = (invoice_data->>'is_taxable')::BOOLEAN, discount_amount = (invoice_data->>'discount_amount')::NUMERIC, discount_type = (invoice_data->>'discount_type')::TEXT,
        contact_person = invoice_data->>'contact_person', project_name = invoice_data->>'project_name', invoice_type = invoice_data->>'invoice_type'
    WHERE id = p_invoice_id;
    DELETE FROM public.invoice_items WHERE invoice_id = p_invoice_id;
    IF items_data IS NOT NULL THEN
        FOR item IN SELECT * FROM jsonb_array_elements(items_data) LOOP
            INSERT INTO public.invoice_items (invoice_id, product_id, description, unit, quantity, price)
            VALUES (p_invoice_id, (item->>'product_id')::BIGINT, item->>'description', item->>'unit', (item->>'quantity')::INT, (item->>'price')::NUMERIC);
        END LOOP;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- SUPPLIER INVOICES --
CREATE OR REPLACE FUNCTION public.create_supplier_invoice_with_items(invoice_data JSONB, items_data JSONB)
RETURNS BIGINT AS $$
DECLARE
    new_invoice_id BIGINT;
    item JSONB;
BEGIN
    INSERT INTO public.supplier_invoices (supplier_id, issue_date, due_date, status, subtotal, tax_rate, tax_amount, total, paid_amount, created_by, is_taxable, discount_amount, discount_type, contact_person, project_name, supplier_invoice_type)
    VALUES (
        (invoice_data->>'supplier_id')::BIGINT, (invoice_data->>'issue_date')::DATE, (invoice_data->>'due_date')::DATE, (invoice_data->>'status')::public.document_status,
        (invoice_data->>'subtotal')::NUMERIC, (invoice_data->>'tax_rate')::NUMERIC, (invoice_data->>'tax_amount')::NUMERIC, (invoice_data->>'total')::NUMERIC, (invoice_data->>'paid_amount')::NUMERIC,
        auth.uid(), (invoice_data->>'is_taxable')::BOOLEAN, (invoice_data->>'discount_amount')::NUMERIC, (invoice_data->>'discount_type')::TEXT,
        invoice_data->>'contact_person', invoice_data->>'project_name', invoice_data->>'supplier_invoice_type'
    ) RETURNING id INTO new_invoice_id;
    IF items_data IS NOT NULL THEN
        FOR item IN SELECT * FROM jsonb_array_elements(items_data) LOOP
            INSERT INTO public.supplier_invoice_items (supplier_invoice_id, product_id, product_name, description, unit, quantity, price)
            VALUES (new_invoice_id, (item->>'product_id')::BIGINT, item->>'product_name', item->>'description', item->>'unit', (item->>'quantity')::INT, (item->>'price')::NUMERIC);
        END LOOP;
    END IF;
    RETURN new_invoice_id;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.update_supplier_invoice_with_items(p_invoice_id BIGINT, invoice_data JSONB, items_data JSONB)
RETURNS VOID AS $$
DECLARE
    item JSONB;
BEGIN
    UPDATE public.supplier_invoices SET
        supplier_id = (invoice_data->>'supplier_id')::BIGINT, issue_date = (invoice_data->>'issue_date')::DATE, due_date = (invoice_data->>'due_date')::DATE, status = (invoice_data->>'status')::public.document_status,
        subtotal = (invoice_data->>'subtotal')::NUMERIC, tax_rate = (invoice_data->>'tax_rate')::NUMERIC, tax_amount = (invoice_data->>'tax_amount')::NUMERIC, total = (invoice_data->>'total')::NUMERIC,
        is_taxable = (invoice_data->>'is_taxable')::BOOLEAN, discount_amount = (invoice_data->>'discount_amount')::NUMERIC, discount_type = (invoice_data->>'discount_type')::TEXT,
        contact_person = invoice_data->>'contact_person', project_name = invoice_data->>'project_name', supplier_invoice_type = invoice_data->>'supplier_invoice_type'
    WHERE id = p_invoice_id;
    DELETE FROM public.supplier_invoice_items WHERE supplier_invoice_id = p_invoice_id;
    IF items_data IS NOT NULL THEN
        FOR item IN SELECT * FROM jsonb_array_elements(items_data) LOOP
            INSERT INTO public.supplier_invoice_items (supplier_invoice_id, product_id, product_name, description, unit, quantity, price)
            VALUES (p_invoice_id, (item->>'product_id')::BIGINT, item->>'product_name', item->>'description', item->>'unit', (item->>'quantity')::INT, (item->>'price')::NUMERIC);
        END LOOP;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- CONVERT QUOTATION --
CREATE OR REPLACE FUNCTION public.convert_quotation_to_invoice(p_quotation_id BIGINT)
RETURNS BIGINT AS $$
DECLARE
  v_quotation RECORD; v_invoice_id BIGINT; v_item RECORD;
BEGIN
  SELECT * INTO v_quotation FROM public.quotations WHERE id = p_quotation_id;
  IF NOT FOUND THEN RAISE EXCEPTION 'Quotation not found or you do not have permission.'; END IF;
  INSERT INTO public.invoices (customer_id, quotation_id, issue_date, due_date, status, subtotal, tax_rate, tax_amount, total, paid_amount, created_by)
  VALUES (v_quotation.customer_id, p_quotation_id, CURRENT_DATE, CURRENT_DATE + 30, 'draft', v_quotation.subtotal, v_quotation.tax_rate, v_quotation.tax_amount, v_quotation.total, 0.00, auth.uid())
  RETURNING id INTO v_invoice_id;
  FOR v_item IN SELECT product_id, description, unit, quantity, price FROM public.quotation_items WHERE quotation_id = p_quotation_id
  LOOP
    INSERT INTO public.invoice_items (invoice_id, product_id, description, unit, quantity, price) VALUES (v_invoice_id, v_item.product_id, v_item.description, v_item.unit, v_item.quantity, v_item.price);
  END LOOP;
  UPDATE public.quotations SET status = 'accepted' WHERE id = p_quotation_id;
  RETURN v_invoice_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
GRANT EXECUTE ON FUNCTION public.convert_quotation_to_invoice(BIGINT) TO authenticated;
*/
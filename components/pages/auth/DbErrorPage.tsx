

import React, { useState } from 'react';
import Button from '../../ui/Button';

const DbErrorPage = () => {
    const [copyButtonText, setCopyButtonText] = useState('Copy SQL Code');

    const correctSqlScript = `-- This script fixes the database security configuration.
-- Run this ENTIRE script in your Supabase SQL Editor. It is safe to run multiple times.

-- Drop existing objects to ensure a clean slate.
DROP FUNCTION IF EXISTS public.handle_new_user() CASCADE;
DROP FUNCTION IF EXISTS public.sync_user_role_to_auth() CASCADE;
DROP FUNCTION IF EXISTS public.get_current_user_role() CASCADE;
DROP FUNCTION IF EXISTS public.convert_quotation_to_invoice(BIGINT) CASCADE;
DROP FUNCTION IF EXISTS public.create_quotation_with_items(JSONB, JSONB) CASCADE;
DROP FUNCTION IF EXISTS public.update_quotation_with_items(BIGINT, JSONB, JSONB) CASCADE;
DROP FUNCTION IF EXISTS public.create_invoice_with_items(JSONB, JSONB) CASCADE;
DROP FUNCTION IF EXISTS public.update_invoice_with_items(BIGINT, JSONB, JSONB) CASCADE;
DROP FUNCTION IF EXISTS public.create_supplier_invoice_with_items(JSONB, JSONB) CASCADE;
DROP FUNCTION IF EXISTS public.update_supplier_invoice_with_items(BIGINT, JSONB, JSONB) CASCADE;
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
DROP TRIGGER IF EXISTS on_user_profile_change ON public.users;
DROP TABLE IF EXISTS public.quotation_items CASCADE;
DROP TABLE IF EXISTS public.invoice_items CASCADE;
DROP TABLE IF EXISTS public.supplier_invoice_items CASCADE;
DROP TABLE IF EXISTS public.receipt_vouchers CASCADE;
DROP TABLE IF EXISTS public.payment_vouchers CASCADE;
DROP TABLE IF EXISTS public.quotations CASCADE;
DROP TABLE IF EXISTS public.invoices CASCADE;
DROP TABLE IF EXISTS public.supplier_invoices CASCADE;
DROP TABLE IF EXISTS public.products CASCADE;
DROP TABLE IF EXISTS public.customers CASCADE;
DROP TABLE IF EXISTS public.suppliers CASCADE;
DROP TABLE IF EXISTS public.users CASCADE;
DROP TABLE IF EXISTS public.roles CASCADE;
DROP TYPE IF EXISTS public.product_type CASCADE;
DROP TYPE IF EXISTS public.document_status CASCADE;
DROP TYPE IF EXISTS public.payment_method CASCADE;


-- 1. ROLES TABLE
CREATE TABLE public.roles (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL
);
ALTER TABLE public.roles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public can view roles" ON public.roles FOR SELECT USING (true);
INSERT INTO public.roles (id, name) VALUES ('admin', 'Admin'), ('accountant', 'Accountant'), ('sales_manager', 'Sales Manager'), ('sales_person', 'Sales Person');

-- 2. USERS TABLE
CREATE TABLE public.users (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name TEXT,
  role TEXT REFERENCES public.roles(id) DEFAULT 'sales_person',
  manager_id UUID REFERENCES public.users(id) ON DELETE SET NULL
);
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

-- 3. NEW USER TRIGGER
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.users (id, full_name)
  VALUES (new.id, new.raw_user_meta_data->>'full_name');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- 4. ROLE SYNC TRIGGER (The key fix for recursion)
CREATE OR REPLACE FUNCTION public.sync_user_role_to_auth()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE auth.users
  SET raw_user_meta_data = raw_user_meta_data || jsonb_build_object('role', NEW.role)
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
CREATE TRIGGER on_user_profile_change
  AFTER INSERT OR UPDATE OF role ON public.users
  FOR EACH ROW EXECUTE FUNCTION public.sync_user_role_to_auth();

-- 5. NON-RECURSIVE RLS POLICIES
-- Users
CREATE POLICY "Users can view and update their own profile" ON public.users
  FOR ALL USING (auth.uid() = id)
  WITH CHECK (auth.uid() = id);
CREATE POLICY "Admins can manage all user profiles" ON public.users
  FOR ALL USING (((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) = 'admin');

-- Customers
CREATE TABLE public.customers (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name TEXT NOT NULL, email TEXT, phone TEXT, address TEXT, created_at TIMESTAMPTZ DEFAULT NOW(), created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL DEFAULT auth.uid());
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage customers based on ownership and role" ON public.customers FOR ALL
USING (created_by = auth.uid() OR ((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) IN ('admin', 'accountant') OR (((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) = 'sales_manager' AND created_by IN (SELECT id FROM public.users WHERE manager_id = auth.uid())));

-- Suppliers
CREATE TABLE public.suppliers (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name TEXT NOT NULL, email TEXT, phone TEXT, address TEXT, created_at TIMESTAMPTZ DEFAULT NOW(), created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL DEFAULT auth.uid());
ALTER TABLE public.suppliers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage suppliers based on ownership and role" ON public.suppliers FOR ALL
USING (created_by = auth.uid() OR ((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) IN ('admin', 'accountant') OR (((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) = 'sales_manager' AND created_by IN (SELECT id FROM public.users WHERE manager_id = auth.uid())));

-- Products
CREATE TYPE public.product_type AS ENUM ('product', 'service');
CREATE TABLE public.products (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    price NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
    type public.product_type NOT NULL DEFAULT 'product',
    category TEXT,
    unit TEXT,
    avg_purchase_price NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
    avg_selling_price NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Authenticated users can manage products" ON public.products FOR ALL USING (auth.role() = 'authenticated');

-- Quotations
CREATE TYPE public.document_status AS ENUM ('draft', 'sent', 'accepted', 'rejected', 'paid', 'overdue', 'unpaid', 'partially_paid');
CREATE TABLE public.quotations (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, customer_id BIGINT REFERENCES public.customers(id) ON DELETE SET NULL, issue_date DATE NOT NULL DEFAULT CURRENT_DATE, status public.document_status NOT NULL DEFAULT 'draft', subtotal NUMERIC(10, 2) NOT NULL DEFAULT 0.00, tax_rate NUMERIC(5, 2) NOT NULL DEFAULT 0.00, tax_amount NUMERIC(10, 2) NOT NULL DEFAULT 0.00, total NUMERIC(10, 2) NOT NULL DEFAULT 0.00, created_at TIMESTAMPTZ DEFAULT NOW(), created_time TIME DEFAULT CURRENT_TIME, created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL DEFAULT auth.uid(), is_taxable BOOLEAN DEFAULT true, discount_amount NUMERIC(10, 2) DEFAULT 0, discount_type TEXT DEFAULT 'amount', contact_person TEXT, project_name TEXT, quotation_type TEXT);
ALTER TABLE public.quotations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage quotations based on ownership and role" ON public.quotations FOR ALL
USING (created_by = auth.uid() OR ((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) IN ('admin', 'accountant') OR (((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) = 'sales_manager' AND created_by IN (SELECT id FROM public.users WHERE manager_id = auth.uid())));

-- Quotation Items
CREATE TABLE public.quotation_items (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, quotation_id BIGINT NOT NULL REFERENCES public.quotations(id) ON DELETE CASCADE, product_id BIGINT REFERENCES public.products(id) ON DELETE SET NULL, description TEXT, unit TEXT, quantity INT NOT NULL DEFAULT 1, price NUMERIC(10, 2) NOT NULL, total NUMERIC(10, 2) GENERATED ALWAYS AS (quantity * price) STORED);
ALTER TABLE public.quotation_items ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage items based on parent document" ON public.quotation_items FOR ALL USING ((SELECT q.created_by FROM public.quotations q WHERE q.id = quotation_id) = auth.uid() OR ((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) IN ('admin', 'accountant') OR (((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) = 'sales_manager' AND (SELECT q.created_by FROM public.quotations q WHERE q.id = quotation_id) IN (SELECT u.id FROM public.users u WHERE u.manager_id = auth.uid())));

-- Invoices
CREATE TABLE public.invoices (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, customer_id BIGINT REFERENCES public.customers(id) ON DELETE SET NULL, quotation_id BIGINT REFERENCES public.quotations(id) ON DELETE SET NULL, issue_date DATE NOT NULL DEFAULT CURRENT_DATE, due_date DATE NOT NULL, status public.document_status NOT NULL DEFAULT 'draft', subtotal NUMERIC(10, 2) NOT NULL DEFAULT 0.00, tax_rate NUMERIC(5, 2) NOT NULL DEFAULT 0.00, tax_amount NUMERIC(10, 2) NOT NULL DEFAULT 0.00, total NUMERIC(10, 2) NOT NULL DEFAULT 0.00, paid_amount NUMERIC(10, 2) NOT NULL DEFAULT 0.00, created_at TIMESTAMPTZ DEFAULT NOW(), created_time TIME DEFAULT CURRENT_TIME, created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL DEFAULT auth.uid(), is_taxable BOOLEAN DEFAULT true, discount_amount NUMERIC(10, 2) DEFAULT 0, discount_type TEXT DEFAULT 'amount', contact_person TEXT, project_name TEXT, invoice_type TEXT);
ALTER TABLE public.invoices ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage invoices based on ownership and role" ON public.invoices FOR ALL
USING (created_by = auth.uid() OR ((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) IN ('admin', 'accountant') OR (((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) = 'sales_manager' AND created_by IN (SELECT id FROM public.users WHERE manager_id = auth.uid())));

-- Invoice Items
CREATE TABLE public.invoice_items (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, invoice_id BIGINT NOT NULL REFERENCES public.invoices(id) ON DELETE CASCADE, product_id BIGINT REFERENCES public.products(id) ON DELETE SET NULL, description TEXT, unit TEXT, quantity INT NOT NULL DEFAULT 1, price NUMERIC(10, 2) NOT NULL, total NUMERIC(10, 2) GENERATED ALWAYS AS (quantity * price) STORED);
ALTER TABLE public.invoice_items ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage items based on parent document" ON public.invoice_items FOR ALL USING ((SELECT i.created_by FROM public.invoices i WHERE i.id = invoice_id) = auth.uid() OR ((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) IN ('admin', 'accountant') OR (((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) = 'sales_manager' AND (SELECT i.created_by FROM public.invoices i WHERE i.id = invoice_id) IN (SELECT u.id FROM public.users u WHERE u.manager_id = auth.uid())));

-- Supplier Invoices
CREATE TABLE public.supplier_invoices (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, supplier_id BIGINT REFERENCES public.suppliers(id) ON DELETE SET NULL, issue_date DATE NOT NULL DEFAULT CURRENT_DATE, due_date DATE NOT NULL, status public.document_status NOT NULL DEFAULT 'unpaid', subtotal NUMERIC(10, 2) NOT NULL DEFAULT 0.00, tax_rate NUMERIC(5, 2) NOT NULL DEFAULT 0.00, tax_amount NUMERIC(10, 2) NOT NULL DEFAULT 0.00, total NUMERIC(10, 2) NOT NULL DEFAULT 0.00, paid_amount NUMERIC(10, 2) NOT NULL DEFAULT 0.00, created_at TIMESTAMPTZ DEFAULT NOW(), created_time TIME DEFAULT CURRENT_TIME, created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL DEFAULT auth.uid(), is_taxable BOOLEAN DEFAULT true, discount_amount NUMERIC(10, 2) DEFAULT 0, discount_type TEXT DEFAULT 'amount', contact_person TEXT, project_name TEXT, supplier_invoice_type TEXT);
ALTER TABLE public.supplier_invoices ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage supplier invoices based on role" ON public.supplier_invoices FOR ALL USING (((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) IN ('admin', 'accountant'));

-- Supplier Invoice Items
CREATE TABLE public.supplier_invoice_items (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, supplier_invoice_id BIGINT NOT NULL REFERENCES public.supplier_invoices(id) ON DELETE CASCADE, product_id BIGINT REFERENCES public.products(id) ON DELETE SET NULL, product_name TEXT NOT NULL, description TEXT, unit TEXT, quantity INT NOT NULL DEFAULT 1, price NUMERIC(10, 2) NOT NULL, total NUMERIC(10, 2) GENERATED ALWAYS AS (quantity * price) STORED);
ALTER TABLE public.supplier_invoice_items ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage items based on parent document" ON public.supplier_invoice_items FOR ALL USING (((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) IN ('admin', 'accountant'));

-- Vouchers
CREATE TYPE public.payment_method AS ENUM ('cash', 'bank_transfer', 'cheque');
CREATE TABLE public.receipt_vouchers (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, customer_id BIGINT REFERENCES public.customers(id) ON DELETE SET NULL, date DATE NOT NULL DEFAULT CURRENT_DATE, amount NUMERIC(10, 2) NOT NULL, payment_method public.payment_method NOT NULL DEFAULT 'cash', description TEXT, created_at TIMESTAMPTZ DEFAULT NOW(), created_time TIME DEFAULT CURRENT_TIME, created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL DEFAULT auth.uid());
ALTER TABLE public.receipt_vouchers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Accountants and admins can manage receipts" ON public.receipt_vouchers FOR ALL USING ( ((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) IN ('admin', 'accountant') );
CREATE TABLE public.payment_vouchers (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, supplier_id BIGINT REFERENCES public.suppliers(id) ON DELETE SET NULL, date DATE NOT NULL DEFAULT CURRENT_DATE, amount NUMERIC(10, 2) NOT NULL, payment_method public.payment_method NOT NULL DEFAULT 'cash', description TEXT, created_at TIMESTAMPTZ DEFAULT NOW(), created_time TIME DEFAULT CURRENT_TIME, created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL DEFAULT auth.uid());
ALTER TABLE public.payment_vouchers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Accountants and admins can manage payments" ON public.payment_vouchers FOR ALL USING ( ((auth.jwt() -> 'raw_user_meta_data' ->> 'role')::text) IN ('admin', 'accountant') );

-- ================== RPC FUNCTIONS ==================

-- QUOTATIONS --
CREATE OR REPLACE FUNCTION public.create_quotation_with_items(quotation_data JSONB, items_data JSONB)
RETURNS BIGINT AS $$
DECLARE
    new_quotation_id BIGINT;
    item JSONB;
BEGIN
    INSERT INTO public.quotations (customer_id, issue_date, status, subtotal, tax_rate, tax_amount, total, created_by, is_taxable, discount_amount, discount_type, contact_person, project_name, quotation_type)
    VALUES (
        (quotation_data->>'customer_id')::BIGINT, (quotation_data->>'issue_date')::DATE, (quotation_data->>'status')::public.document_status,
        (quotation_data->>'subtotal')::NUMERIC, (quotation_data->>'tax_rate')::NUMERIC, (quotation_data->>'tax_amount')::NUMERIC, (quotation_data->>'total')::NUMERIC,
        auth.uid(), (quotation_data->>'is_taxable')::BOOLEAN, (quotation_data->>'discount_amount')::NUMERIC, (quotation_data->>'discount_type')::TEXT,
        quotation_data->>'contact_person', quotation_data->>'project_name', quotation_data->>'quotation_type'
    ) RETURNING id INTO new_quotation_id;

    IF items_data IS NOT NULL THEN
        FOR item IN SELECT * FROM jsonb_array_elements(items_data) LOOP
            INSERT INTO public.quotation_items (quotation_id, product_id, description, unit, quantity, price)
            VALUES (new_quotation_id, (item->>'product_id')::BIGINT, item->>'description', item->>'unit', (item->>'quantity')::INT, (item->>'price')::NUMERIC);
        END LOOP;
    END IF;
    RETURN new_quotation_id;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.update_quotation_with_items(p_quotation_id BIGINT, quotation_data JSONB, items_data JSONB)
RETURNS VOID AS $$
DECLARE
    item JSONB;
BEGIN
    UPDATE public.quotations SET
        customer_id = (quotation_data->>'customer_id')::BIGINT, issue_date = (quotation_data->>'issue_date')::DATE, status = (quotation_data->>'status')::public.document_status,
        subtotal = (quotation_data->>'subtotal')::NUMERIC, tax_rate = (quotation_data->>'tax_rate')::NUMERIC, tax_amount = (quotation_data->>'tax_amount')::NUMERIC, total = (quotation_data->>'total')::NUMERIC,
        is_taxable = (quotation_data->>'is_taxable')::BOOLEAN, discount_amount = (quotation_data->>'discount_amount')::NUMERIC, discount_type = (quotation_data->>'discount_type')::TEXT,
        contact_person = quotation_data->>'contact_person', project_name = quotation_data->>'project_name', quotation_type = quotation_data->>'quotation_type'
    WHERE id = p_quotation_id;
    DELETE FROM public.quotation_items WHERE quotation_id = p_quotation_id;
    IF items_data IS NOT NULL THEN
        FOR item IN SELECT * FROM jsonb_array_elements(items_data) LOOP
            INSERT INTO public.quotation_items (quotation_id, product_id, description, unit, quantity, price)
            VALUES (p_quotation_id, (item->>'product_id')::BIGINT, item->>'description', item->>'unit', (item->>'quantity')::INT, (item->>'price')::NUMERIC);
        END LOOP;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- INVOICES --
CREATE OR REPLACE FUNCTION public.create_invoice_with_items(invoice_data JSONB, items_data JSONB)
RETURNS BIGINT AS $$
DECLARE
    new_invoice_id BIGINT;
    item JSONB;
BEGIN
    INSERT INTO public.invoices (customer_id, issue_date, due_date, status, subtotal, tax_rate, tax_amount, total, paid_amount, created_by, is_taxable, discount_amount, discount_type, contact_person, project_name, invoice_type)
    VALUES (
        (invoice_data->>'customer_id')::BIGINT, (invoice_data->>'issue_date')::DATE, (invoice_data->>'due_date')::DATE, (invoice_data->>'status')::public.document_status,
        (invoice_data->>'subtotal')::NUMERIC, (invoice_data->>'tax_rate')::NUMERIC, (invoice_data->>'tax_amount')::NUMERIC, (invoice_data->>'total')::NUMERIC, (invoice_data->>'paid_amount')::NUMERIC,
        auth.uid(), (invoice_data->>'is_taxable')::BOOLEAN, (invoice_data->>'discount_amount')::NUMERIC, (invoice_data->>'discount_type')::TEXT,
        invoice_data->>'contact_person', invoice_data->>'project_name', invoice_data->>'invoice_type'
    ) RETURNING id INTO new_invoice_id;
    IF items_data IS NOT NULL THEN
        FOR item IN SELECT * FROM jsonb_array_elements(items_data) LOOP
            INSERT INTO public.invoice_items (invoice_id, product_id, description, unit, quantity, price)
            VALUES (new_invoice_id, (item->>'product_id')::BIGINT, item->>'description', item->>'unit', (item->>'quantity')::INT, (item->>'price')::NUMERIC);
        END LOOP;
    END IF;
    RETURN new_invoice_id;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.update_invoice_with_items(p_invoice_id BIGINT, invoice_data JSONB, items_data JSONB)
RETURNS VOID AS $$
DECLARE
    item JSONB;
BEGIN
    UPDATE public.invoices SET
        customer_id = (invoice_data->>'customer_id')::BIGINT, issue_date = (invoice_data->>'issue_date')::DATE, due_date = (invoice_data->>'due_date')::DATE, status = (invoice_data->>'status')::public.document_status,
        subtotal = (invoice_data->>'subtotal')::NUMERIC, tax_rate = (invoice_data->>'tax_rate')::NUMERIC, tax_amount = (invoice_data->>'tax_amount')::NUMERIC, total = (invoice_data->>'total')::NUMERIC,
        is_taxable = (invoice_data->>'is_taxable')::BOOLEAN, discount_amount = (invoice_data->>'discount_amount')::NUMERIC, discount_type = (invoice_data->>'discount_type')::TEXT,
        contact_person = invoice_data->>'contact_person', project_name = invoice_data->>'project_name', invoice_type = invoice_data->>'invoice_type'
    WHERE id = p_invoice_id;
    DELETE FROM public.invoice_items WHERE invoice_id = p_invoice_id;
    IF items_data IS NOT NULL THEN
        FOR item IN SELECT * FROM jsonb_array_elements(items_data) LOOP
            INSERT INTO public.invoice_items (invoice_id, product_id, description, unit, quantity, price)
            VALUES (p_invoice_id, (item->>'product_id')::BIGINT, item->>'description', item->>'unit', (item->>'quantity')::INT, (item->>'price')::NUMERIC);
        END LOOP;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- SUPPLIER INVOICES --
CREATE OR REPLACE FUNCTION public.create_supplier_invoice_with_items(invoice_data JSONB, items_data JSONB)
RETURNS BIGINT AS $$
DECLARE
    new_invoice_id BIGINT;
    item JSONB;
BEGIN
    INSERT INTO public.supplier_invoices (supplier_id, issue_date, due_date, status, subtotal, tax_rate, tax_amount, total, paid_amount, created_by, is_taxable, discount_amount, discount_type, contact_person, project_name, supplier_invoice_type)
    VALUES (
        (invoice_data->>'supplier_id')::BIGINT, (invoice_data->>'issue_date')::DATE, (invoice_data->>'due_date')::DATE, (invoice_data->>'status')::public.document_status,
        (invoice_data->>'subtotal')::NUMERIC, (invoice_data->>'tax_rate')::NUMERIC, (invoice_data->>'tax_amount')::NUMERIC, (invoice_data->>'total')::NUMERIC, (invoice_data->>'paid_amount')::NUMERIC,
        auth.uid(), (invoice_data->>'is_taxable')::BOOLEAN, (invoice_data->>'discount_amount')::NUMERIC, (invoice_data->>'discount_type')::TEXT,
        invoice_data->>'contact_person', invoice_data->>'project_name', invoice_data->>'supplier_invoice_type'
    ) RETURNING id INTO new_invoice_id;
    IF items_data IS NOT NULL THEN
        FOR item IN SELECT * FROM jsonb_array_elements(items_data) LOOP
            INSERT INTO public.supplier_invoice_items (supplier_invoice_id, product_id, product_name, description, unit, quantity, price)
            VALUES (new_invoice_id, (item->>'product_id')::BIGINT, item->>'product_name', item->>'description', item->>'unit', (item->>'quantity')::INT, (item->>'price')::NUMERIC);
        END LOOP;
    END IF;
    RETURN new_invoice_id;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.update_supplier_invoice_with_items(p_invoice_id BIGINT, invoice_data JSONB, items_data JSONB)
RETURNS VOID AS $$
DECLARE
    item JSONB;
BEGIN
    UPDATE public.supplier_invoices SET
        supplier_id = (invoice_data->>'supplier_id')::BIGINT, issue_date = (invoice_data->>'issue_date')::DATE, due_date = (invoice_data->>'due_date')::DATE, status = (invoice_data->>'status')::public.document_status,
        subtotal = (invoice_data->>'subtotal')::NUMERIC, tax_rate = (invoice_data->>'tax_rate')::NUMERIC, tax_amount = (invoice_data->>'tax_amount')::NUMERIC, total = (invoice_data->>'total')::NUMERIC,
        is_taxable = (invoice_data->>'is_taxable')::BOOLEAN, discount_amount = (invoice_data->>'discount_amount')::NUMERIC, discount_type = (invoice_data->>'discount_type')::TEXT,
        contact_person = invoice_data->>'contact_person', project_name = invoice_data->>'project_name', supplier_invoice_type = invoice_data->>'supplier_invoice_type'
    WHERE id = p_invoice_id;
    DELETE FROM public.supplier_invoice_items WHERE supplier_invoice_id = p_invoice_id;
    IF items_data IS NOT NULL THEN
        FOR item IN SELECT * FROM jsonb_array_elements(items_data) LOOP
            INSERT INTO public.supplier_invoice_items (supplier_invoice_id, product_id, product_name, description, unit, quantity, price)
            VALUES (p_invoice_id, (item->>'product_id')::BIGINT, item->>'product_name', item->>'description', item->>'unit', (item->>'quantity')::INT, (item->>'price')::NUMERIC);
        END LOOP;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- CONVERT QUOTATION --
CREATE OR REPLACE FUNCTION public.convert_quotation_to_invoice(p_quotation_id BIGINT)
RETURNS BIGINT AS $$
DECLARE
  v_quotation RECORD; v_invoice_id BIGINT; v_item RECORD;
BEGIN
  SELECT * INTO v_quotation FROM public.quotations WHERE id = p_quotation_id;
  IF NOT FOUND THEN RAISE EXCEPTION 'Quotation not found or you do not have permission.'; END IF;
  INSERT INTO public.invoices (customer_id, quotation_id, issue_date, due_date, status, subtotal, tax_rate, tax_amount, total, paid_amount, created_by)
  VALUES (v_quotation.customer_id, p_quotation_id, CURRENT_DATE, CURRENT_DATE + 30, 'draft', v_quotation.subtotal, v_quotation.tax_rate, v_quotation.tax_amount, v_quotation.total, 0.00, auth.uid())
  RETURNING id INTO v_invoice_id;
  FOR v_item IN SELECT product_id, description, unit, quantity, price FROM public.quotation_items WHERE quotation_id = p_quotation_id
  LOOP
    INSERT INTO public.invoice_items (invoice_id, product_id, description, unit, quantity, price) VALUES (v_invoice_id, v_item.product_id, v_item.description, v_item.unit, v_item.quantity, v_item.price);
  END LOOP;
  UPDATE public.quotations SET status = 'accepted' WHERE id = p_quotation_id;
  RETURN v_invoice_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
GRANT EXECUTE ON FUNCTION public.convert_quotation_to_invoice(BIGINT) TO authenticated;
`;

    const copyToClipboard = () => {
        navigator.clipboard.writeText(correctSqlScript.trim())
            .then(() => {
                setCopyButtonText('Copied!');
                setTimeout(() => setCopyButtonText('Copy SQL Code'), 2000);
            })
            .catch(err => {
                setCopyButtonText('Failed to copy');
                console.error('Failed to copy: ', err)
            });
    };

    return (
        <div className="flex items-center justify-center min-h-screen bg-slate-100 dark:bg-slate-900 p-4 font-sans">
            <div className="w-full max-w-3xl p-6 sm:p-8 space-y-6 bg-white dark:bg-slate-800 rounded-2xl shadow-xl border-t-4 border-red-500">
                <div className="text-center">
                    <h1 className="text-3xl font-extrabold text-slate-800 dark:text-slate-100">Database Security Fix Required</h1>
                    <p className="mt-2 text-slate-600 dark:text-slate-400">
                        A critical security function in your database is misconfigured, causing a loop. Please follow the steps below to fix it.
                    </p>
                    <p className="mt-1 text-sm text-slate-500 dark:text-slate-500">This is a one-time setup step that must be done in your Supabase project dashboard.</p>
                </div>

                <div className="space-y-5">
                    {/* Step 1 */}
                    <div>
                        <div className="flex items-center gap-3 mb-2">
                            <div className="flex items-center justify-center bg-sky-600 text-white rounded-full w-8 h-8 flex-shrink-0 font-bold text-lg">1</div>
                            <h3 className="font-bold text-lg text-slate-700 dark:text-slate-200">Copy the SQL Script</h3>
                        </div>
                        <div className="ps-11">
                            <p className="text-sm text-slate-500 dark:text-slate-400 mb-3">This script defines all the necessary tables and security functions to prevent the recursion error.</p>
                            <div className="relative bg-slate-900 rounded-lg">
                                <pre className="text-sm text-slate-300 p-4 overflow-x-auto max-h-60 rounded-lg scrollbar-thin scrollbar-thumb-slate-600 scrollbar-track-slate-800">
                                    <code>{correctSqlScript.trim()}</code>
                                </pre>
                                <button
                                    onClick={copyToClipboard}
                                    className="absolute top-2 end-2 bg-slate-700 text-white text-xs font-semibold py-1 px-3 rounded-md hover:bg-slate-600 transition-colors"
                                >
                                    {copyButtonText}
                                </button>
                            </div>
                        </div>
                    </div>

                    {/* Step 2 */}
                    <div>
                        <div className="flex items-center gap-3 mb-2">
                            <div className="flex items-center justify-center bg-sky-600 text-white rounded-full w-8 h-8 flex-shrink-0 font-bold text-lg">2</div>
                            <h3 className="font-bold text-lg text-slate-700 dark:text-slate-200">Navigate to Supabase SQL Editor</h3>
                        </div>
                        <div className="ps-11 text-sm text-slate-500 dark:text-slate-400">
                           <p>Open your project on <a href="https://app.supabase.com" target="_blank" rel="noopener noreferrer" className="text-sky-500 hover:underline">app.supabase.com</a>. In the left sidebar, click the <strong className="text-slate-600 dark:text-slate-300">Database icon</strong>, then click on <strong className="text-slate-600 dark:text-slate-300">SQL Editor</strong>.</p>
                        </div>
                    </div>

                    {/* Step 3 */}
                    <div>
                        <div className="flex items-center gap-3 mb-2">
                            <div className="flex items-center justify-center bg-sky-600 text-white rounded-full w-8 h-8 flex-shrink-0 font-bold text-lg">3</div>
                            <h3 className="font-bold text-lg text-slate-700 dark:text-slate-200">Paste and Run the Script</h3>
                        </div>
                         <div className="ps-11 text-sm text-slate-500 dark:text-slate-400">
                           <p>In the SQL Editor, paste the code you copied. Click the green <strong className="text-slate-600 dark:text-slate-300">RUN</strong> button. You should see a "Success" message.</p>
                        </div>
                    </div>
                </div>
                
                <div className="text-center pt-4">
                  <Button variant="primary" size="lg" onClick={() => window.location.reload()}>
                    I Have Run the Script, Log Me In
                  </Button>
                </div>
            </div>
        </div>
    );
};

export default DbErrorPage;
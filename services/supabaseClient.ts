
import { createClient } from '@supabase/supabase-js';
import { SUPABASE_CONFIG } from '../config';

// Note: The Supabase client is initialized with placeholder credentials.
// You must replace them in `config.ts` with your actual Supabase project details.
export const supabase = createClient(SUPABASE_CONFIG.URL, SUPABASE_CONFIG.ANON_KEY);


/*
================================================================================
 SUPABASE DATABASE SCHEMA AND FUNCTIONS
================================================================================
Copy and run the following SQL code in your Supabase SQL Editor to set up the
database tables, relationships, and the RPC function for the 'إنجاز' application.
================================================================================

-- Enable Row Level Security (RLS) on all tables
-- This is a security best practice. You should define policies for access.
-- For this example, we will disable it for simplicity, but in production, you MUST enable it.

-- 1. ROLES TABLE
CREATE TABLE roles (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL
);
ALTER TABLE roles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public can view roles" ON roles FOR SELECT USING (true);
-- Seed the roles table
INSERT INTO roles (id, name) VALUES 
('admin', 'Admin'), 
('accountant', 'Accountant'), 
('sales_manager', 'Sales Manager'),
('sales_person', 'Sales Person');

-- 2. USERS TABLE (using supabase auth.users)
-- We'll add a 'role' column to the public users table which links to auth.users
CREATE TABLE users (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name TEXT,
  role TEXT REFERENCES roles(id) DEFAULT 'sales_person',
  manager_id UUID REFERENCES users(id) ON DELETE SET NULL -- Self-referencing for hierarchy
);
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can see their own profile" ON users FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Admins can see all profiles" ON users FOR SELECT USING ( (SELECT role FROM users WHERE id = auth.uid()) = 'admin' );
CREATE POLICY "Users can update their own profile" ON users FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "Admins can update all profiles" ON users FOR UPDATE USING ( (SELECT role FROM users WHERE id = auth.uid()) = 'admin' );


-- Function to get the current user's role from the public.users table
CREATE OR REPLACE FUNCTION get_current_user_role()
RETURNS TEXT AS $$
DECLARE
  user_role TEXT;
BEGIN
  SELECT role INTO user_role FROM public.users WHERE id = auth.uid();
  RETURN user_role;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- 3. CUSTOMERS TABLE
CREATE TABLE customers (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  email TEXT,
  phone TEXT,
  address TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL DEFAULT auth.uid()
);
ALTER TABLE customers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage customers based on ownership and role" ON customers FOR ALL
USING (
  created_by = auth.uid() OR -- Owner can do anything
  get_current_user_role() IN ('admin', 'accountant') OR -- Admins/Accountants can do anything
  (get_current_user_role() = 'sales_manager' AND created_by IN (SELECT id FROM users WHERE manager_id = auth.uid())) -- Manager can manage team's customers
);


-- 4. SUPPLIERS TABLE
CREATE TABLE suppliers (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  email TEXT,
  phone TEXT,
  address TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL DEFAULT auth.uid()
);
ALTER TABLE suppliers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage suppliers based on ownership and role" ON suppliers FOR ALL
USING (
  created_by = auth.uid() OR
  get_current_user_role() IN ('admin', 'accountant') OR
  (get_current_user_role() = 'sales_manager' AND created_by IN (SELECT id FROM users WHERE manager_id = auth.uid()))
);


-- 5. PRODUCTS TABLE (Typically not owned, so keep it simple)
CREATE TYPE product_type AS ENUM ('product', 'service');
CREATE TABLE products (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  price NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
  type product_type NOT NULL DEFAULT 'product',
  created_at TIMESTAMPTZ DEFAULT NOW()
);
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Authenticated users can manage products" ON products FOR ALL USING (auth.role() = 'authenticated');


-- 6. QUOTATIONS TABLE
CREATE TYPE document_status AS ENUM ('draft', 'sent', 'accepted', 'rejected', 'paid', 'overdue', 'unpaid', 'partially_paid');
CREATE TABLE quotations (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  customer_id BIGINT REFERENCES customers(id) ON DELETE SET NULL,
  issue_date DATE NOT NULL DEFAULT CURRENT_DATE,
  expiry_date DATE NOT NULL,
  status document_status NOT NULL DEFAULT 'draft',
  subtotal NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
  tax_rate NUMERIC(5, 2) NOT NULL DEFAULT 0.00,
  tax_amount NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
  total NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL DEFAULT auth.uid()
);
ALTER TABLE quotations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage quotations based on ownership and role" ON quotations FOR ALL
USING (
  created_by = auth.uid() OR
  get_current_user_role() IN ('admin', 'accountant') OR
  (get_current_user_role() = 'sales_manager' AND created_by IN (SELECT id FROM users WHERE manager_id = auth.uid()))
);


-- 7. QUOTATION_ITEMS TABLE
CREATE TABLE quotation_items (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  quotation_id BIGINT NOT NULL REFERENCES quotations(id) ON DELETE CASCADE,
  product_id BIGINT REFERENCES products(id) ON DELETE SET NULL,
  quantity INT NOT NULL DEFAULT 1,
  price NUMERIC(10, 2) NOT NULL,
  total NUMERIC(10, 2) GENERATED ALWAYS AS (quantity * price) STORED
);
ALTER TABLE quotation_items ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Authenticated users can manage quotation items" ON quotation_items FOR ALL USING (auth.role() = 'authenticated');


-- 8. INVOICES TABLE
CREATE TABLE invoices (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  customer_id BIGINT REFERENCES customers(id) ON DELETE SET NULL,
  quotation_id BIGINT REFERENCES quotations(id) ON DELETE SET NULL,
  issue_date DATE NOT NULL DEFAULT CURRENT_DATE,
  due_date DATE NOT NULL,
  status document_status NOT NULL DEFAULT 'draft',
  subtotal NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
  tax_rate NUMERIC(5, 2) NOT NULL DEFAULT 0.00,
  tax_amount NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
  total NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
  paid_amount NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL DEFAULT auth.uid()
);
ALTER TABLE invoices ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage invoices based on ownership and role" ON invoices FOR ALL
USING (
  created_by = auth.uid() OR
  get_current_user_role() IN ('admin', 'accountant') OR
  (get_current_user_role() = 'sales_manager' AND created_by IN (SELECT id FROM users WHERE manager_id = auth.uid()))
);


-- 9. INVOICE_ITEMS TABLE
CREATE TABLE invoice_items (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  invoice_id BIGINT NOT NULL REFERENCES invoices(id) ON DELETE CASCADE,
  product_id BIGINT REFERENCES products(id) ON DELETE SET NULL,
  quantity INT NOT NULL DEFAULT 1,
  price NUMERIC(10, 2) NOT NULL,
  total NUMERIC(10, 2) GENERATED ALWAYS AS (quantity * price) STORED
);
ALTER TABLE invoice_items ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Authenticated users can manage invoice items" ON invoice_items FOR ALL USING (auth.role() = 'authenticated');


-- 10. SUPPLIER_INVOICES
CREATE TABLE supplier_invoices (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    supplier_id BIGINT REFERENCES suppliers(id) ON DELETE SET NULL,
    issue_date DATE NOT NULL DEFAULT CURRENT_DATE,
    due_date DATE NOT NULL,
    status document_status NOT NULL DEFAULT 'unpaid',
    subtotal NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
    tax_rate NUMERIC(5, 2) NOT NULL DEFAULT 0.00,
    tax_amount NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
    total NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
    paid_amount NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL DEFAULT auth.uid()
);
ALTER TABLE supplier_invoices ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage supplier invoices based on role" ON supplier_invoices FOR ALL 
USING (get_current_user_role() IN ('admin', 'accountant'));


-- 11. SUPPLIER_INVOICE_ITEMS
CREATE TABLE supplier_invoice_items (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    supplier_invoice_id BIGINT NOT NULL REFERENCES supplier_invoices(id) ON DELETE CASCADE,
    description TEXT NOT NULL,
    quantity INT NOT NULL DEFAULT 1,
    price NUMERIC(10, 2) NOT NULL,
    total NUMERIC(10, 2) GENERATED ALWAYS AS (quantity * price) STORED
);
ALTER TABLE supplier_invoice_items ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Authenticated users can manage supplier invoice items" ON supplier_invoice_items FOR ALL USING (auth.role() = 'authenticated');

-- 12. RECEIPT VOUCHERS
CREATE TYPE payment_method AS ENUM ('cash', 'bank_transfer', 'cheque');
CREATE TABLE receipt_vouchers (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    customer_id BIGINT REFERENCES customers(id) ON DELETE SET NULL,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    amount NUMERIC(10, 2) NOT NULL,
    payment_method payment_method NOT NULL DEFAULT 'cash',
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL DEFAULT auth.uid()
);
ALTER TABLE receipt_vouchers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Accountants and admins can manage receipts" ON receipt_vouchers FOR ALL 
USING ( get_current_user_role() IN ('admin', 'accountant') );


-- 13. PAYMENT VOUCHERS
CREATE TABLE payment_vouchers (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    supplier_id BIGINT REFERENCES suppliers(id) ON DELETE SET NULL,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    amount NUMERIC(10, 2) NOT NULL,
    payment_method payment_method NOT NULL DEFAULT 'cash',
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL DEFAULT auth.uid()
);
ALTER TABLE payment_vouchers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Accountants and admins can manage payments" ON payment_vouchers FOR ALL 
USING ( get_current_user_role() IN ('admin', 'accountant') );


-- 14. RPC FUNCTION: convert_quotation_to_invoice
CREATE OR REPLACE FUNCTION convert_quotation_to_invoice(p_quotation_id BIGINT)
RETURNS BIGINT AS $$
DECLARE
  v_quotation RECORD;
  v_invoice_id BIGINT;
  v_item RECORD;
BEGIN
  -- 1. Find the quotation (RLS is enforced on the underlying table)
  SELECT * INTO v_quotation FROM quotations WHERE id = p_quotation_id;
  
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Quotation not found or you do not have permission.';
  END IF;
  
  -- 2. Create a new invoice
  INSERT INTO invoices (customer_id, quotation_id, issue_date, due_date, status, subtotal, tax_rate, tax_amount, total, paid_amount, created_by)
  VALUES (v_quotation.customer_id, p_quotation_id, CURRENT_DATE, CURRENT_DATE + INTERVAL '30 days', 'draft', v_quotation.subtotal, v_quotation.tax_rate, v_quotation.tax_amount, v_quotation.total, 0.00, auth.uid())
  RETURNING id INTO v_invoice_id;
  
  -- 3. Copy items from quotation_items to invoice_items
  FOR v_item IN
    SELECT product_id, quantity, price FROM quotation_items WHERE quotation_id = p_quotation_id
  LOOP
    INSERT INTO invoice_items (invoice_id, product_id, quantity, price)
    VALUES (v_invoice_id, v_item.product_id, v_item.quantity, v_item.price);
  END LOOP;
  
  -- 4. Update the quotation status to 'accepted'
  UPDATE quotations SET status = 'accepted' WHERE id = p_quotation_id;
  
  -- 5. Return the new invoice ID
  RETURN v_invoice_id;
  
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
GRANT EXECUTE ON FUNCTION convert_quotation_to_invoice(BIGINT) TO authenticated;

*/
